# Development notes

This directory contains the naïve buffer compiler (`nbufc`), which compiles
a textual schema into its binary form, and then generate code manipulating
the data types defined in the schema.

The format of the binary schema is (recursively) defined in naïve buffers,
whose schema is defined in `lib/nbuf.nbs`.
The buffer contains a single message of `Schema`, which contains:

* The package name (possibly empty).
* A list of `message` definitions.
* A list of `enum` definitions.

## Bootstrapping

Most of the code depends on `nbuf.nb.h` to manipulate the binary schema.
However, that header itself is generated by `nbufc`, leading to the
chicken-and-egg problem.  The bootstrapping process is as follows:

1. A first version of `nbuf.nb.h` was constructed manually.
2. A program was written to generate a binary schema for `nbuf.nbs`, where the
   data is hard-coded so that a parser is not necessary.
3. With the generated header file and binary schema, code generator (`b2h.c`)
   was developed.
4. The code generator generates a new header file, replacing the hand-crafted
   version in step 1.
5. A parser was written to parse textual schema and generate binary, replacing
   the one generated in step 2.

When all of the above steps are done, a schema compiler is availble to compile
*any* textual schema, including but not limited to `nbuf.nbs`.

The generated `nbuf.nb.h` is checked into the code repository so bootstrapping
is not necessary.

## Schema details

Some of the concepts, e.g., scalar part and pointer part, are described in
`spec.txt`.

The most interesting attributes in the schema are the following:

* `kind` refers to the kind of the type of a field.  Combined with `tag1`,
  one can determine a specific type.
  * For `INT`, `UINT` and `FLOAT` kinds, `tag1` specifies the size of the
    type.  For example, `INT` with `tag1==4` means `int32`.
  * For `ENUM` kind, `tag1` is the corresponding index to `enumTypes[]`
    for the actual enum type.
  * For `PTR` kind (meaning a submessage), `tag1` is the corresponding index
    to `msgTypes[]` for the actual message type.
* `tag0` is the offset of the field in the message.
  * For `STR`, `PTR` kinds or list fields, this is the index to the pointer
    part.
  * For `BOOL` kinds, this is the bit-offset.
  * For any other kinds, this is the byte-offset.

Note: `tag0` and `tag1` are bad names and the overloaded usage of `tag1`
is very obscure.

## Code generation

A C header is generated by `b2h.c` to define all the data types and accessor
functions.

Code generation is basically broken down into the following stages:
1. Output header (`outhdr`).  This includes the `#ifndef` guard, any `#include`
   statements, etc.
2. Generate enums (`genenums`).  This gives the definition of all enums.
3. Generate messages (`genmsgs`).  This gives the definition of all messages
   along with associated functions.
4. Output footer (`outftr`).  This includes the `#endif` for the `#ifndef`
   guard, and any other external declarations.

The C++ header is generated similarly (by `b2hh.c`), except it is more
complicated because each method need a declaration inside the class and a
defintion outside the class.  The method cannot be defined in-line because it
may refer to other classes that have not been defined yet.

## Parser and binary generation

The lexical and grammar analyzers are implemented using `flex` and `bison`.

The parser uses a temporary, dynamically allocated, intermediate
representation of the schema.  The ideal solution would generate the binary
schema directly, but it is hard for list fields because they cannot be
resized easily.

Conversion from the intermediate representation to the binary schema is
done in `t2b.c`.  It creates a `Schema` message, and fills in the data
for enum and messages types.  Some work needs to be done for the message types:

* For each field, the type is specified with a name.  This has to be translated
  into appropriate `kind`/`tag1` combinations.
* The offset (`tag0`) must be computed in this stage.  This is complicated
  for scalar types because padding and alignment must be taken into
  consideration.
